\documentclass[12pt]{article}
\usepackage[a4paper, portrait, margin=1in]{geometry}
\bibliographystyle{ieeetr}

\begin{document}
\nocite{*}

\title{Caderno de Infraestrutura de Hardware}
\author{Marconi Gomes}

\maketitle


\section{Introdução - Instruções e funcionamento básico}
    \subsection{Abstração}
    As linguages de programação podem ser divididas em \textbf{4 níveis}:
    \\- Linguagem de Máquina (binário)
    \\- Linguagem de montagem (Assembly)
    \\- Linguagem de alto nível (Java, C++, etc)
    \\- Linguagem de 4ª gearção (PL/SQL, NATURAL, etc)
    \\~\\O menor nível de abstração que o programador pode ver antes do código de realmente chegar ao binário, chama-se Instruction Set Architeture (ISA), que é um \textbf{repositório de instruções}, ela é realmente a interface entre Software e Hardware. Ela vai me dizer quais as intruções e registradores que posso usar, como acessar a memória, etc.

    \subsection{Assembly}
    É uma linguagem que é dependente de arquitetua, ou seja, para cada tipo (x86, ARM) é um tipo de assembly diferente.

    \subsection{Compilador}
    \textbf{Definição:} é um programa que traduz de uma linguagem de mais alto nível (ex. Java) para uma de menor nível (assembly) que o computador entende.
    \\A diferença entre um \textbf{compilador} e um \textbf{interpretador} é que o compilador traduz tudo primeiramente apenas e depois executa. O interpretador traduz e executa cada linha por vez. 
    \\Exemplos de linguages compiladas (completamente): C, C++, etc.
    \\Exemplos de linguages interpretadas (completamente): JavaScript, Python.
    \\Exemplos de linguages semi-interpretadas e semi-compiladas: Java!

    \subsection{Visão funcional de um computador}
    Um computador pode (e deve) realizar 4 ações: 
    \\$\rightarrow$ Mover dados (Barramento)
    \\$\rightarrow$ Controlar ações (CPU)
    \\$\rightarrow$ Armazenar dados (Memória)
    \\$\rightarrow$ Processar dados (CPU)
    \\~\\Logo, a CPU faz sempre as seguintes coisas:  
    \\ Busca $\rightarrow$ Decodificação $\rightarrow$ Execução
    \\~\\Os seguintes registradores são os mais comuns num computador:
    \\\textbf{PC (Program counter)}: Buscar o endereço da instrução
    \\\textbf{MAR (Memory Address Register)}: Guarda dinamicamente endereços que possam ser usados posteriormente.
    \\\textbf{IR (Instruction Register)}: Recebe a instrução do PC e a armazena.
    \\\textbf{AC (Acumulator)}: É um registrador comum genérico.

    \subsection{Evolução das ISAs}
    Inicialmente as ISAs tinham poucas instruções básicas, dificultando o trabalho dos programadores, então foram implementadas instruções mais complexas,
    assim surgiram os \textbf{CISC} (Complex Instruction Set Computer) e \textbf{RISC} (Reduced Instruction Set Computer).
    \\Exemplos de processadores CISC: Intel x86, AMD, etc\dots
    \\Exemplos de processadores RISC: ARMS, MIPS, etc\dots

\section{MIPS}
    \subsection{Instruções - Aritméticas}
    As instruções aritméticas no MIPS \textbf{sempre} (exceto multiplicação e divisão) \textbf{possuem 3 operandos}: destino, fonte 1 e fonte 2.
    \\- Cada instrução só faz \textbf{uma} operação aritmética.
    \\- Para ser mais eficiente, os operandos de uma instrução aritmética devem estar nos registradores.
    \\- No MIPS \textbf{todos} os registradores possuem 32 bits, ou seja, 4bytes e logo 32 bits são uma \textbf{word}.
    \\~\\- No MIPS os registradores tem nomes da forma: \$sX (para armazenar variáveis de programas, onde \textbf{X varia de 0 a 7}) e \$tY (para armazenar valores temporários, onde \textbf{Y varia de 0 até 9}).
    \\Internamente, o processador categoriza iniciando de \$t0 até \$t7 como os registradores 0 a 15, os \$s0 até \$s7 sendo de 16 a 23, e finalmente \$t8 e \$t9 como 24 e 25 respectivamente.
    \\~\\\textbf{Formato de instrução:} O espaço de 32 bits (word) é dividido em 6 espaços, respectivamente por:
    \\1º - op (6 bits) --- [Armazena o opcode da instrução]
    \\2º - rs (5 bits) --- [Registrador que contém 1º operando fonte]
    \\3º - rt (5 bits) --- [Registrador que contém 2º operando fonte]
    \\4º - rd (5 bits)  --- [Registrador destino que contém o resultado]
    \\5º - shamt (5 bits)  --- [Shift Amount, que não é utilizado para add e sub]
    \\6º - funct (6 bits) --- [Função que estende o opcode]
    
\bibliography{references}
\end{document} 